se:
            self.tpl = Template(file=self.filename, **options)

    def render(self, *args, **kwargs):
        for dictarg in args: kwargs.update(dictarg)
        self.context.vars.update(self.defaults)
        self.context.vars.update(kwargs)
        out = str(self.tpl)
        self.context.vars.clear()
        return out


class Jinja2Template(BaseTemplate):
    def prepare(self, filters=None, tests=None, globals={}, **kwargs):
        from jinja2 import Environment, FunctionLoader
        if 'prefix' in kwargs: # TODO: to be removed after a while
            raise RuntimeError('The keyword argument `prefix` has been removed. '
                'Use the full jinja2 environment name line_statement_prefix instead.')
        self.env = Environment(loader=FunctionLoader(self.loader), **kwargs)
        if filters: self.env.filters.update(filters)
        if tests: self.env.tests.update(tests)
        if globals: self.env.globals.update(globals)
        if self.source:
            self.tpl = self.env.from_string(self.source)
        else:
            self.tpl = self.env.get_template(self.filename)

    def render(self, *args, **kwargs):
        for dictarg in args: kwargs.update(dictarg)
        _defaults = self.defaults.copy()
        _defaults.update(kwargs)
        return self.tpl.render(**_defaults)

    def loader(self, name):
        fname = self.search(name, self.lookup)
        if not fname: return
        with open(fname, "rb") as f:
            return f.read().decode(self.encoding)


class SimpleTemplate(BaseTemplate):

    def prepare(self, escape_func=html_escape, noescape=False, syntax=None, **ka):
        self.cache = {}
        enc = self.encoding
        self._str = lambda x: touni(x, enc)
        self._escape = lambda x: escape_func(touni(x, enc))
        self.syntax = syntax
        if noescape:
            self._str, self._escape = self._escape, self._str

    @cached_property
    def co(self):
        return compile(self.code, self.filename or '<string>', 'exec')

    @cached_property
    def code(self):
        source = self.source
        if not source:
            with open(self.filename, 'rb') as f:
                source = f.read()
        try:
            source, encoding = touni(source), 'utf8'
        except UnicodeError:
            depr('Template encodings other than utf8 are no longer supported.') #0.11
            source, encoding = touni(source, 'latin1'), 'latin1'
        parser = StplParser(source, encoding=encoding, syntax=self.syntax)
        code = parser.translate()
        self.encoding = parser.encoding
        return code

    def _rebase(self, _env, _name=None, **kwargs):
        if _name is None:
            depr('Rebase function called without arguments.'
                 ' You were probably looking for {{base}}?', True) #0.12
        _env['_rebase'] = (_name, kwargs)

    def _include(self, _env, _name=None, **kwargs):
        if _name is None:
            depr('Rebase function called without arguments.'
                 ' You were probably looking for {{base}}?', True) #0.12
        env = _env.copy()
        env.update(kwargs)
        if _name not in self.cache:
            self.cache[_name] = self.__class__(name=_name, lookup=self.lookup)
        return self.cache[_name].execute(env['_stdout'], env)

    def execute(self, _stdout, kwargs):
        env = self.defaults.copy()
        env.update(kwargs)
        env.update({'_stdout': _stdout, '_printlist': _stdout.extend,
            'include': functools.partial(self._include, env),
            'rebase': functools.partial(self._rebase, env), '_rebase': None,
            '_str': self._str, '_escape': self._escape, 'get': env.get,
            'setdefault': env.setdefault, 'defined': env.__contains__ })
        eval(self.co, env)
        if env.get('_rebase'):
            subtpl, rargs = env.pop('_rebase')
            rargs['base'] = ''.join(_stdout) #copy stdout
            del _stdout[:] # clear stdout
            return self._include(env, subtpl, **rargs)
        return env

    def render(self, *args, **kwargs):
        """ Render the template using keyword arguments as local variables. """
        env = {}; stdout = []
        for dictarg in args: env.update(dictarg)
        env.update(kwargs)
        self.execute(stdout, env)
        return ''.join(stdout)


class StplSyntaxError(TemplateError): pass


class StplParser(object):
    ''' Parser for stpl templates. '''
    _re_cache = {} #: Cache for compiled re patterns
    # This huge pile of voodoo magic splits python code into 8 different tokens.
    # 1: All kinds of python strings (trust me, it works)
    _re_tok = '((?m)[urbURB]?(?:\'\'(?!\')|""(?!")|\'{6}|"{6}' \
               '|\'(?:[^\\\\\']|\\\\.)+?\'|"(?:[^\\\\"]|\\\\.)+?"' \
               '|\'{3}(?:[^\\\\]|\\\\.|\\n)+?\'{3}' \
               '|"{3}(?:[^\\\\]|\\\\.|\\n)+?"{3}))'
    _re_inl = _re_tok.replace('|\\n','') # We re-use this string pattern later
    # 2: Comments (until end of line, but not the newline itself)
    _re_tok += '|(#.*)'
    # 3,4: Open and close grouping tokens
    _re_tok += '|([\[\{\(])'
    _re_tok += '|([\]\}\)])'
    # 5,6: Keywords that start or continue a python block (only start of line)
    _re_tok += '|^([ \\t]*(?:if|for|while|with|try|def|class)\\b)' \
               '|^([ \\t]*(?:elif|else|except|finally)\\b)'
    # 7: Our special 'end' keyword (but only if it stands alone)
    _re_tok += '|((?:^|;)[ \\t]*end[ \\t]*(?=(?:%(block_close)s[ \\t]*)?\\r?$|;|#))'
    # 8: A customizable end-of-code-block template token (only end of line)
    _re_tok += '|(%(block_close)s[ \\t]*(?=\\r?$))'
    # 9: And finally, a single newline. The 10th token is 'everything else'
    _re_tok += '|(\\r?\\n)'

    # Match the start tokens of code areas in a template
    _re_split = '(?m)^[ \t]*(\\\\?)((%(line_start)s)|(%(block_start)s))(%%?)'
    # Match inline statements (may contain python strings)
    _re_inl = '%%(inline_start)s((?:%s|[^\'"\n]*?)+)%%(inline_end)s' % _re_inl

    default_syntax = '<% %> % {{ }}'

    def __init__(self, source, syntax=None, encoding='utf8'):
        self.source, self.encoding = touni(source, encoding), encoding
        self.set_syntax(syntax or self.default_syntax)
        self.code_buffer, self.text_buffer = [], []
        self.lineno, self.offset = 1, 0
        self.indent, self.indent_mod = 0, 0
        self.paren_depth = 0

    def get_syntax(self):
        ''' Tokens as a space separated string (default: <% %> % {{ }}) '''
        return self._syntax

    def set_syntax(self, syntax):
        self._syntax = syntax
        self._tokens = syntax.split()
        if not syntax in self._re_cache:
            names = 'block_start block_close line_start inline_start inline_end'
            etokens = map(re.escape, self._tokens)
            pattern_vars = dict(zip(names.split(), etokens))
            patterns = (self._re_split, self._re_tok, self._re_inl)
            patterns = [re.compile(p%pattern_vars) for p in patterns]
            self._re_cache[syntax] = patterns
        self.re_split, self.re_tok, self.re_inl = self._re_cache[syntax]

    syntax = property(get_syntax, set_syntax)

    def translate(self):
        if self.offset: raise RuntimeError('Parser is a one time instance.')
        while True:
            m = self.re_split.search(self.source[self.offset:])
            if m:
                text = self.source[self.offset:self.offset+m.start()]
                self.text_buffer.append(text)
                self.offset += m.end()
                if m.group(1): # New escape syntax
                    line, sep, _ = self.source[self.offset:].partition('\n')
                    self.text_buffer.append(m.group(2)+m.group(5)+line+sep)
                    self.offset += len(line+sep)+1
                    continue
                elif m.group(5): # Old escape syntax
                    depr('Escape code lines with a backslash.') #0.12
                    line, sep, _ = self.source[self.offset:].partition('\n')
                    self.text_buffer.append(m.group(2)+line+sep)
                    self.offset += len(line+sep)+1
                    continue
                self.flush_text()
                self.read_code(multiline=bool(m.group(4)))
            else: break
        self.text_buffer.append(self.source[self.offset:])
        self.flush_text()
        return ''.join(self.code_buffer)

    def read_code(self, multiline):
        code_line, comment = '', ''
        while True:
            m = self.re_tok.search(self.source[self.offset:])
            if not m:
                code_line += self.source[self.offset:]
                self.offset = len(self.source)
                self.write_code(code_line.strip(), comment)
                return
            code_line += self.source[self.offset:self.offset+m.start()]
            self.offset += m.end()
            _str, _com, _po, _pc, _blk1, _blk2, _end, _cend, _nl = m.groups()
            if (code_line or self.paren_depth > 0) and (_blk1 or _blk2): # a if b else c
                code_line += _blk1 or _blk2
                continue
            if _str:    # Python string
                code_line += _str
            elif _com:  # Python comment (up to EOL)
                comment = _com
                if multiline and _com.strip().endswith(self._tokens[1]):
                    multiline = False # Allow end-of-block in comments
            elif _po:  # open parenthesis
                self.paren_depth += 1
                code_line += _po
            elif _pc:  # close parenthesis
                if self.paren_depth > 0:
                    # we could check for matching parentheses here, but it's
                    # easier to leave that to python - just check counts
                    self.paren_depth -= 1
                code_line += _pc
            elif _blk1: # Start-block keyword (if/for/while/def/try/...)
                code_line, self.indent_mod = _blk1, -1
                self.indent += 1
            elif _blk2: # Continue-block keyword (else/elif/except/...)
                code_line, self.indent_mod = _blk2, -1
            elif _end:  # The non-standard 'end'-keyword (ends a block)
                self.indent -= 1
            elif _cend: # The end-code-block template token (usually '%>')
                if multiline: multiline = False
                else: code_line += _cend
            else: # \n
                self.write_code(code_line.strip(), comment)
                self.lineno += 1
                code_line, comment, self.indent_mod = '', '', 0
                if not multiline:
                    break

    def flush_text(self):
        text = ''.join(self.text_buffer)
        del self.text_buffer[:]
        if not text: return
        parts, pos, nl = [], 0, '\\\n'+'  '*self.indent
        for m in self.re_inl.finditer(text):
            prefix, pos = text[pos:m.start()], m.end()
            if prefix:
                parts.append(nl.join(map(repr, prefix.splitlines(True))))
            if prefix.endswith('\n'): parts[-1] += nl
            parts.append(self.process_inline(m.group(1).strip()))
        if pos < len(text):
            prefix = text[pos:]
            lines = prefix.splitlines(True)
            if lines[-1].endswith('\\\\\n'): lines[-1] = lines[-1][:-3]
            elif lines[-1].endswith('\\\\\r\n'): lines[-1] = lines[-1][:-4]
            parts.append(nl.join(map(repr, lines)))
        code = '_printlist((%s,))' % ', '.join(parts)
        self.lineno += code.count('\n')+1
        self.write_code(code)

    def process_inline(self, chunk):
        if chunk[0] == '!': return '_str(%s)' % chunk[1:]
        return '_escape(%s)' % chunk

    def write_code(self, line, comment=''):
        line, comment = self.fix_backward_compatibility(line, comment)
        code  = '  ' * (self.indent+self.indent_mod)
        code += line.lstrip() + comment + '\n'
        self.code_buffer.append(code)

    def fix_backward_compatibility(self, line, comment):
        parts = line.strip().split(None, 2)
        if parts and parts[0] in ('include', 'rebase'):
            depr('The include and rebase keywords are functions now.') #0.12
            if len(parts) == 1:   return "_printlist([base])", comment
            elif len(parts) == 2: return "_=%s(%r)" % tuple(parts), comment
            else:                 return "_=%s(%r, %s)" % tuple(parts), comment
        if self.lineno <= 2 and not line.strip() and 'coding' in comment:
            m = re.match(r"#.*coding[:=]\s*([-\w.]+)", comment)
            if m:
                depr('PEP263 encoding strings in templates are deprecated.') #0.12
                enc = m.group(1)
                self.source = self.source.encode(self.encoding).decode(enc)
                self.encoding = enc
                return line, comment.replace('coding','coding*')
        return line, comment


def template(*args, **kwargs):
    '''
    Get a rendered template as a string iterator.
    You can use a name, a filename or a template string as first parameter.
    Template rendering arguments can be passed as dictionaries
    or directly (as keyword arguments).
    '''
    tpl = args[0] if args else None
    adapter = kwargs.pop('template_adapter', SimpleTemplate)
    lookup = kwargs.pop('template_lookup', TEMPLATE_PATH)
    tplid = (id(lookup), tpl)
    if tplid not in TEMPLATES or DEBUG:
        settings = kwargs.pop('template_settings', {})
        if isinstance(tpl, adapter):
            TEMPLATES[tplid] = tpl
            if settings: TEMPLATES[tplid].prepare(**settings)
        elif "\n" in tpl or "{" in tpl or "%" in tpl or '$' in tpl:
            TEMPLATES[tplid] = adapter(source=tpl, lookup=lookup, **settings)
        else:
            TEMPLATES[tplid] = adapter(name=tpl, lookup=lookup, **settings)
    if not TEMPLATES[tplid]:
        abort(500, 'Template (%s) not found' % tpl)
    for dictarg in args[1:]: kwargs.update(dictarg)
    return TEMPLATES[tplid].render(kwargs)

mako_template = functools.partial(template, template_adapter=MakoTemplate)
cheetah_template = functools.partial(template, template_adapter=CheetahTemplate)
jinja2_template = functools.partial(template, template_adapter=Jinja2Template)


def view(tpl_name, **defaults):
    ''' Decorator: renders a template for a handler.
        The handler can control its behavior like that:

          - return a dict of template vars to fill out the template
          - return something other than a dict and the view decorator will not
            process the template, but return the handler result as is.
            This includes returning a HTTPResponse(dict) to get,
            for instance, JSON with autojson or other castfilters.
    '''
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            result = func(*args, **kwargs)
            if isinstance(result, (dict, DictMixin)):
                tplvars = defaults.copy()
                tplvars.update(result)
                return template(tpl_name, **tplvars)
            elif result is None:
                return template(tpl_name, defaults)
            return result
        return wrapper
    return decorator

mako_view = functools.partial(view, template_adapter=MakoTemplate)
cheetah_view = functools.partial(view, template_adapter=CheetahTemplate)
jinja2_view = functools.partial(view, template_adapter=Jinja2Template)






###############################################################################
# Constants and Globals ########################################################
###############################################################################


TEMPLATE_PATH = ['./', './views/']
TEMPLATES = {}
DEBUG = False
NORUN = False # If set, run() does nothing. Used by load_app()

#: A dict to map HTTP status codes (e.g. 404) to phrases (e.g. 'Not Found')
HTTP_CODES = httplib.responses
HTTP_CODES[418] = "I'm a teapot" # RFC 2324
HTTP_CODES[422] = "Unprocessable Entity" # RFC 4918
HTTP_CODES[428] = "Precondition Required"
HTTP_CODES[429] = "Too Many Requests"
HTTP_CODES[431] = "Request Header Fields Too Large"
HTTP_CODES[511] = "Network Authentication Required"
_HTTP_STATUS_LINES = dict((k, '%d %s'%(k,v)) for (k,v) in HTTP_CODES.items())

#: The default template used for error pages. Override with @error()
ERROR_PAGE_TEMPLATE = """
%%try:
    %%from %s import DEBUG, HTTP_CODES, request, touni
    <!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
    <html>
        <head>
            <title>Error: {{e.status}}</title>
            <style type="text/css">
              html {background-color: #eee; font-family: sans;}
              body {background-color: #fff; border: 1px solid #ddd;
                    padding: 15px; margin: 15px;}
              pre {background-color: #eee; border: 1px solid #ddd; padding: 5px;}
            </style>
        </head>
        <body>
            <h1>Error: {{e.status}}</h1>
            <p>Sorry, the requested URL <tt>{{repr(request.url)}}</tt>
               caused an error:</p>
            <pre>{{e.body}}</pre>
            %%if DEBUG and e.exception:
              <h2>Exception:</h2>
              <pre>{{repr(e.exception)}}</pre>
            %%end
            %%if DEBUG and e.traceback:
              <h2>Traceback:</h2>
              <pre>{{e.traceback}}</pre>
            %%end
        </body>
    </html>
%%except ImportError:
    <b>ImportError:</b> Could not generate the error page. Please add bottle to
    the import path.
%%end
""" % __name__

#: A thread-safe instance of :class:`LocalRequest`. If accessed from within a
#: request callback, this instance always refers to the *current* request
#: (even on a multithreaded server).
request = LocalRequest()

#: A thread-safe instance of :class:`LocalResponse`. It is used to change the
#: HTTP response for the *current* request.
response = LocalResponse()

#: A thread-safe namespace. Not used by Bottle.
local = threading.local()

# Initialize app stack (create first empty Bottle app)
# BC: 0.6.4 and needed for run()
app = default_app = AppStack()
app.push()

#: A virtual package that redirects import statements.
#: Example: ``import bottle.ext.sqlite`` actually imports `bottle_sqlite`.
ext = _ImportRedirect('bottle.ext' if __name__ == '__main__' else __name__+".ext", 'bottle_%s').module

if __name__ == '__main__':
    opt, args, parser = _cmd_options, _cmd_args, _cmd_parser
    if opt.version:
        _stdout('Bottle %s\n'%__version__)
        sys.exit(0)
    if not args:
        parser.print_help()
        _stderr('\nError: No application specified.\n')
        sys.exit(1)

    sys.path.insert(0, '.')
    sys.modules.setdefault('bottle', sys.modules['__main__'])

    host, port = (opt.bind or 'localhost'), 8080
    if ':' in host and host.rfind(']') < host.rfind(':'):
        host, port = host.rsplit(':', 1)
    host = host.strip('[]')

    run(args[0], host=host, port=int(port), server=opt.server,
        reloader=opt.reload, plugins=opt.plugin, debug=opt.debug)




# THE END
Û
$|[c           @Ä  sç  d  Z  d d l m Z d Z d Z d Z e d k r5d d l m Z e d d	 É Z	 e	 j
 Z e d
 d d d d Ée d d d d d d Ée d d d d d d Ée d d d d d d Ée d d d d d Ée d d d d d  Ée	 j É  \ Z Z e j oe j j d! É r2d d" l Z e j j É  n  n  d d" l Z d d" l Z d d" l Z d d" l Z d d" l Z d d" l Z d d" l Z d d" l Z d d" l Z d d" l Z d d" l  Z  d d" l! Z! d d" l" Z" d d" l# Z# d d" l$ Z$ d d" l% Z% d d# l& m' Z( m& Z& m) Z) d d$ l" m* Z* d d% l+ m, Z, m- Z- d d& l. m/ Z/ d d' l0 m1 Z1 y d d( l2 m3 Z4 m5 Z6 Wn| e7 k
 rÔy d d( l8 m3 Z4 m5 Z6 WnN e7 k
 rÎy d d( l9 m3 Z4 m5 Z6 Wn  e7 k
 rÁd) Ñ  Z4 e4 Z6 n Xn Xn Xe! j: Z; e; d* d+ d+ f k Z< e; d, d- d+ f k  Z= d* d. d+ f e; k oLd* d, d+ f k  n Z> d/ Ñ  Z? y" e! j@ jA e! jB jA f \ ZC ZD Wn# eE k
 r°d0 Ñ  ZC d1 Ñ  ZD n Xe< rÜd d" lF jG ZH d d" lI ZJ d d2 lK mL ZL mM ZN d d3 lK mO ZO mP ZQ mR ZS e jT eS d4 d5 ÉZS d d6 lU mV ZV d d7 lW mX ZY d d" lZ ZZ d d8 l[ m\ Z\ d d9 l] m^ Z^ e_ Z` e_ Za d: Ñ  Zb d; Ñ  Zc ed Ze d< Ñ  Zf nd d" lH ZH d d" lJ ZJ d d2 lg mL ZL mM ZN d d3 lh mO ZO mP ZQ mR ZS d d6 li mV ZV d d= l me Ze d d" lj ZZ d d> lk mk Z\ d d? l^ ml Z^ e= rZd@ Zm e% jn em eo É d dA lp mY ZY dB Ñ  Zq e_ Zr n d d7 lW mX ZY ea Za e6 Zb es et dC dD dE É É dF dG Ñ Zu dF dH dI Ñ Zv e< r≥ev n eu Zw e> rËd dJ l[ mx Zx dK ex f dL Ñ  É  YZy n  dM Ñ  Zz e{ dN Ñ Z| dO Ñ  Z} dP e~ f dQ Ñ  É  YZ dR e~ f dS Ñ  É  YZÄ dT e~ f dU Ñ  É  YZÅ dV eÇ f dW Ñ  É  YZÉ dX eÉ f dY Ñ  É  YZÑ dZ eÉ f d[ Ñ  É  YZÖ d\ eÑ f d] Ñ  É  YZÜ d^ eÑ f d_ Ñ  É  YZá d` eÑ f da Ñ  É  YZà db Ñ  Zâ dc e~ f dd Ñ  É  YZä de e~ f df Ñ  É  YZã dg e~ f dh Ñ  É  YZå di e~ f dj Ñ  É  YZç dk Ñ  Zé dl Ñ  Zè dm e~ f dn Ñ  É  YZê do e~ f dp Ñ  É  YZë eí dq Ñ Zì dr eç f ds Ñ  É  YZî dt eë f du Ñ  É  YZï eç Zñ eë Zó dv eó eÉ f dw Ñ  É  YZò dx eò f dy Ñ  É  YZô dz eÉ f d{ Ñ  É  YZö d| e~ f d} Ñ  É  YZõ d~ e~ f d Ñ  É  YZú dÄ e~ f dÅ Ñ  É  YZù dÇ eY f dÉ Ñ  É  YZû dÑ eû f dÖ Ñ  É  YZü dÜ eû f dá Ñ  É  YZ† dà eY f dâ Ñ  É  YZ° dä e¢ f dã Ñ  É  YZ£ då e§ f dç Ñ  É  YZ• dé e~ f dè Ñ  É  YZ¶ dê e~ f dë Ñ  É  YZß dí e~ f dì Ñ  É  YZ® dî e~ f dï Ñ  É  YZ© dñ dó dò Ñ Z™ eí dô Ñ Z´ dö dö dõ Ñ Z¨ dú e{ dù dû Ñ Z≠ eÆ dü Ñ ZØ d† Ñ  Z∞ d° Ñ  Z± d¢ Ñ  Z≤ d+ d£ Ñ Z≥ d§ Ñ  Z¥ d• Ñ  Zµ d¶ Ñ  Z∂ dß Ñ  Z∑ d® Ñ  Z∏ d© Ñ  Zπ d™ Ñ  Z∫ d´ Ñ  Zª d. d¨ Ñ Zº d≠ dÆ dØ Ñ ZΩ d∞ Ñ  Zæ eæ d± É Zø eæ d≤ É Z¿ eæ d≥ É Z¡ eæ d¥ É Z¬ eæ dµ É Z√ eæ d∂ É Zƒ eæ d∑ É Z≈ eæ d∏ É Z∆ eæ dπ É Z« eæ d∫ É Z» eæ dª É Z… dº e~ f dΩ Ñ  É  YZ  dæ e  f dø Ñ  É  YZÀ d¿ e  f d¡ Ñ  É  YZÃ d¬ e  f d√ Ñ  É  YZÕ dƒ e  f d≈ Ñ  É  YZŒ d∆ e  f d« Ñ  É  YZœ d» e  f d… Ñ  É  YZ– d  e  f dÀ Ñ  É  YZ— dÃ e  f dÕ Ñ  É  YZ“ dŒ e  f dœ Ñ  É  YZ” d– e  f d— Ñ  É  YZ‘ d“ e  f d” Ñ  É  YZ’ d‘ e  f d’ Ñ  É  YZ÷ d÷ e  f d◊ Ñ  É  YZ◊ dÿ e  f dŸ Ñ  É  YZÿ d⁄ e  f d€ Ñ  É  YZŸ d‹ e  f d› Ñ  É  YZ⁄ dﬁ e  f dﬂ Ñ  É  YZ€ d‡ e  f d· Ñ  É  YZ‹ d‚ e  f d„ Ñ  É  YZ› i eÀ d‰ 6eÃ dÂ 6eÕ d 6eœ dÊ 6eŒ dÁ 6e– dË 6e“ dÈ 6e” dÍ 6e‘ dÎ 6e’ dÏ 6e÷ dÌ 6e— dÓ 6eŸ dÔ 6e⁄ d 6e◊ d! 6eÿ dÒ 6e€ dÚ 6e‹ dÛ 6e› dú 6Zﬁ dÙ Ñ  Zﬂ dı Ñ  Z‡ eØ Z· eí d dˆ d˜ d. e{ e{ eí eí d¯ Ñ	 Z‚ d˘ e# j„ f d˙ Ñ  É  YZ‰ d˚ eô f d¸ Ñ  É  YZÂ d˝ e~ f d˛ Ñ  É  YZÊ dˇ eÊ f d Ñ  É  YZÁ deÊ f dÑ  É  YZË deÊ f dÑ  É  YZÈ deÊ f dÑ  É  YZÍ deÂ f dÑ  É  YZÎ d	e~ f d
Ñ  É  YZÏ dÑ  ZÌ e jT eÌ deÁ ÉZÓ e jT eÌ deË ÉZÔ e jT eÌ deÈ ÉZ dÑ  ZÒ e jT eÒ deÁ ÉZÚ e jT eÒ deË ÉZÛ e jT eÒ deÈ ÉZÙ ddg Zı i  Zˆ e{ a˜ e{ a¯ eH j˘ Z˙ de˙ d<de˙ d<de˙ d<de˙ d<de˙ d<de˙ d<e¢ dÑ  e˙ j˚ É  DÉ É Z¸ de Z˝ eî É  Z˛ eï É  Zˇ e# j É  Z e• É  ZZejÉ  eù e d k rdn e dd É jZe d k râe e e	 f \ ZZZej	r{eC d!e É e! j
d+ É n  er¶ejÉ  eD d"É e! j
d. É n  e! jjd+ d#É e! jjd$e! jd É ejpﬂd%d˜ f \ ZZd&ek oejd'É ejd&É k  r3ejd&d. É \ ZZn  ejd(É Ze‚ ed+ d)ed*eeÉ d+ej d,ejd-ejd.ejØ Én  d" S(/  sÕ  
Bottle is a fast and simple micro-framework for small web applications. It
offers request dispatching (Routes) with url parameter support, templates,
a built-in HTTP Server and adapters for many third party WSGI/HTTP-server and
template engines - all in a single file and with no dependencies other than the
Python Standard Library.

Homepage and documentation: http://bottlepy.org/

Copyright (c) 2016, Marcel Hellkamp.
License: MIT (see LICENSE for details)
iˇˇˇˇ(   t   with_statements   Marcel Hellkamps   0.12.13t   MITt   __main__(   t   OptionParsert   usages)   usage: %prog [options] package.module:apps	   --versiont   actiont
   store_truet   helps   show version number.s   -bs   --bindt   metavart   ADDRESSs   bind socket to ADDRESS.s   -ss   --servert   defaultt   wsgirefs   use SERVER as backend.s   -ps   --plugint   appends   install additional plugin/s.s   --debugs   start server in debug mode.s   --reloads   auto-reload on file changes.t   geventN(   t   datet   datetimet	   timedelta(   t   TemporaryFile(   t
   format_exct	   print_exc(   t
   getargspec(   t	   normalize(   t   dumpst   loadsc         CÄ  s   t  d É Ç d  S(   Ns/   JSON support requires Python 2.6 or simplejson.(   t   ImportError(   t   data(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt
   json_dumps6   s    i   i    i   i   i   c           CÄ  s   t  j É  d S(   Ni   (   t   syst   exc_info(    (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   _eE   s    c         CÄ  s   t  j j |  É S(   N(   R   t   stdoutt   write(   t   x(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   <lambda>L   s    c         CÄ  s   t  j j |  É S(   N(   R   t   stderrR   (   R    (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR!   M   s    (   t   urljoint   SplitResult(   t	   urlencodet   quotet   unquotet   encodingt   latin1(   t   SimpleCookie(   t   MutableMapping(   t   BytesIO(   t   ConfigParserc         CÄ  s   t  t |  É É S(   N(   t   json_ldst   touni(   t   s(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR!   ]   s    c         CÄ  s   t  |  d É S(   Nt   __call__(   t   hasattr(   R    (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR!   ^   s    c          GÄ  s%   |  d |  d É j  |  d É Ç d  S(   Ni    i   i   (   t   with_traceback(   t   a(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   _raise`   s    (   t   imap(   t   StringIO(   t   SafeConfigParsers?   Python 2.5 support may be dropped in future versions of Bottle.(   t	   DictMixinc         CÄ  s
   |  j  É  S(   N(   t   next(   t   it(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR:   o   s    s&   def _raise(*a): raise a[0], a[1], a[2]s   <py3fix>t   exect   utf8c         CÄ  s&   t  |  t É r |  j | É St |  É S(   N(   t
   isinstancet   unicodet   encodet   bytes(   R0   t   enc(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   tobx   s    t   strictc         CÄ  s)   t  |  t É r |  j | | É St |  É S(   N(   R>   RA   t   decodeR?   (   R0   RB   t   err(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR/   z   s    (   t   TextIOWrappert   NCTextIOWrapperc           BÄ  s   e  Z d  Ñ  Z RS(   c         CÄ  s   d  S(   N(    (   t   self(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   closeÉ   s    (   t   __name__t
   __module__RJ   (    (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRH   Ç   s   c         OÄ  s2   y t  j |  | | | é Wn t k
 r- n Xd  S(   N(   t	   functoolst   update_wrappert   AttributeError(   t   wrappert   wrappedR4   t   ka(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRN   á   s      c         CÄ  s   t  j |  t d d Éd  S(   Nt
   stackleveli   (   t   warningst   warnt   DeprecationWarning(   t   messaget   hard(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   deprê   s    c         CÄ  s:   t  |  t t t t f É r% t |  É S|  r2 |  g Sg  Sd  S(   N(   R>   t   tuplet   listt   sett   dict(   R   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   makelistì   s
     
 t   DictPropertyc           BÄ  sA   e  Z d  Z d e d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 RS(   s=    Property that maps to a key in a local dict-like attribute. c         CÄ  s!   | | | |  _  |  _ |  _ d  S(   N(   t   attrt   keyt	   read_only(   RI   R`   Ra   Rb   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   __init__õ   s    c         CÄ  s9   t  j |  | d g  É| |  j p( | j |  _ |  _ |  S(   Nt   updated(   RM   RN   Ra   RK   t   getter(   RI   t   func(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR1   û   s    c         CÄ  sV   | d  k r |  S|  j t | |  j É } } | | k rN |  j | É | | <n  | | S(   N(   t   NoneRa   t   getattrR`   Re   (   RI   t   objt   clsRa   t   storage(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   __get__£   s      c         CÄ  s5   |  j  r t d É Ç n  | t | |  j É |  j <d  S(   Ns   Read-Only property.(   Rb   RO   Rh   R`   Ra   (   RI   Ri   t   value(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   __set__©   s    	 c         CÄ  s2   |  j  r t d É Ç n  t | |  j É |  j =d  S(   Ns   Read-Only property.(   Rb   RO   Rh   R`   Ra   (   RI   Ri   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt
   __delete__≠   s    	 N(
   RK   RL   t   __doc__Rg   t   FalseRc   R1   Rl   Rn   Ro   (    (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR_   ô   s   			t   cached_propertyc           BÄ  s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   s•    A property that is only computed once per instance and then replaces
        itself with an ordinary attribute. Deleting the attribute resets the
        property. c         CÄ  s   t  | d É |  _ | |  _ d  S(   NRp   (   Rh   Rp   Rf   (   RI   Rf   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRc   ∑   s    c         CÄ  s4   | d  k r |  S|  j | É } | j |  j j <| S(   N(   Rg   Rf   t   __dict__RK   (   RI   Ri   Rj   Rm   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRl   ª   s      (   RK   RL   Rp   Rc   Rl   (    (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRr   ≤   s   	t   lazy_attributec           BÄ  s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   s4    A property that caches itself to the class object. c         CÄ  s#   t  j |  | d g  É| |  _ d  S(   NRd   (   RM   RN   Re   (   RI   Rf   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRc   √   s    c         CÄ  s&   |  j  | É } t | |  j | É | S(   N(   Re   t   setattrRK   (   RI   Ri   Rj   Rm   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRl   «   s    (   RK   RL   Rp   Rc   Rl   (    (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRt   ¡   s   	t   BottleExceptionc           BÄ  s   e  Z d  Z RS(   s-    A base class for exceptions used by bottle. (   RK   RL   Rp   (    (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRv   ÷   s   t
   RouteErrorc           BÄ  s   e  Z d  Z RS(   s9    This is a base class for all routing related exceptions (   RK   RL   Rp   (    (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRw   ‰   s   t
   RouteResetc           BÄ  s   e  Z d  Z RS(   sf    If raised by a plugin or request handler, the route is reset and all
        plugins are re-applied. (   RK   RL   Rp   (    (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRx   Ë   s   t   RouterUnknownModeErrorc           BÄ  s   e  Z RS(    (   RK   RL   (    (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRy   Ï   s    t   RouteSyntaxErrorc           BÄ  s   e  Z d  Z RS(   s@    The route parser found something not supported by this router. (   RK   RL   Rp   (    (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRz   Ô   s   t   RouteBuildErrorc           BÄ  s   e  Z d  Z RS(   s    The route could not be built. (   RK   RL   Rp   (    (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR{   Û   s   c         CÄ  s&   d |  k r |  St  j d d Ñ  |  É S(   s^    Turn all capturing groups in a regular expression pattern into
        non-capturing groups. t   (s   (\\*)(\(\?P<[^>]+>|\((?!\?))c         SÄ  s7   t  |  j d É É d r& |  j d É S|  j d É d S(   Ni   i   i    s   (?:(   t   lent   group(   t   m(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR!   ¸   s    (   t   ret   sub(   t   p(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   _re_flatten˜   s     	t   Routerc           BÄ  st   e  Z d  Z d Z d Z d Z e d Ñ Z d Ñ  Z e	 j
 d É Z d Ñ  Z d d Ñ Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z RS(   sA   A Router is an ordered collection of route->target pairs. It is used to
        efficiently match WSGI requests against a number of routes and return
        the first target that satisfies the request. The target may be anything,
        usually a string, ID or callable object. A route consists of a path-rule
        and a HTTP method.

        The path-rule is either a static path (e.g. `/contact`) or a dynamic
        path that contains wildcards (e.g. `/wiki/<page>`). The wildcard syntax
        and details on the matching order are described in docs:`routing`.
    s   [^/]+RÄ   ic   c         Ä  sz   g  à  _  i  à  _ i  à  _ i  à  _ i  à  _ i  à  _ | à  _ i á  f d Ü  d 6d Ñ  d 6d Ñ  d 6d Ñ  d 6à  _ d  S(	   Nc         Ä  s   t  |  p à  j É d  d  f S(   N(   RÉ   t   default_patternRg   (   t   conf(   RI   (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR!     s    RÄ   c         SÄ  s   d t  d Ñ  f S(   Ns   -?\d+c         SÄ  s   t  t |  É É S(   N(   t   strt   int(   R    (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR!     s    (   Rà   (   RÜ   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR!     s    Rà   c         SÄ  s   d t  d Ñ  f S(   Ns   -?[\d.]+c         SÄ  s   t  t |  É É S(   N(   Rá   t   float(   R    (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR!     s    (   Râ   (   RÜ   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR!     s    Râ   c         SÄ  s   d S(   Ns   .+?(   s   .+?NN(   Rg   (   RÜ   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR!      s    t   path(   t   rulest   _groupst   buildert   statict   dyna_routest   dyna_regexest   strict_ordert   filters(   RI   RD   (    (   RI   s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRc     s    							

c         CÄ  s   | |  j  | <d S(   s‚    Add a filter. The provided function is called with the configuration
        string as parameter and must return a (regexp, to_python, to_url) tuple.
        The first element is a string, the last two are callables or None. N(   Rí   (   RI   t   nameRf   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt
   add_filter"  s    sÄ   (\\*)(?:(?::([a-zA-Z_][a-zA-Z_0-9]*)?()(?:#(.*?)#)?)|(?:<([a-zA-Z_][a-zA-Z_0-9]*)?(?::([a-zA-Z_]*)(?::((?:\\.|[^\\>]+)+)?)?)?>))c   	      cÄ  s?  d \ } } x˚ |  j  j | É D]Á } | | | | j É  !7} | j É  } t | d É d rè | | j d É t | d É 7} | j É  } q n  | r¶ | d  d  f Vn  | d d  k r√ | d d !n
 | d d !\ } } } | | pÂ d | pÓ d  f V| j É  d } } q W| t | É k s"| r;| | | d  d  f Vn  d  S(	   Ni    t    i   i   i   i   R
   (   i    Rï   (   t   rule_syntaxt   finditert   startt   groupsR}   R~   t   endRg   (	   RI   t   rulet   offsett   prefixt   matcht   gRì   t   filtrRÜ   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   _itertokens-  s    !3c         Ä  s˛  d } g  } d } g  â  g  } t  }	 x|  j | É D]\ }
 } } | rt }	 | d k rg |  j } n  |  j | | É \ } } } |
 sÆ | d | 7} d | }
 | d 7} n! | d |
 | f 7} | j |
 É | rÎ à  j |
 | f É n  | j |
 | p˝ t f É q4 |
 r4 | t j |
 É 7} | j d |
 f É q4 q4 W| |  j
 | <| r]| |  j
 | <n  |	 r§|  j r§|  j j | i  É | d f |  j | |  j | É <d Sy  t j d	 | É } | j â Wn- t j k
 rÛt d
 | t É  f É Ç n Xà  rá  á f d Ü  } n! | j r*á f d Ü  } n d } t | É } | | | | f } | | f |  j k r≠t råd } t j | | | f t É n  | |  j | |  j | | f <n@ |  j j | g  É j | É t |  j | É d |  j | | f <|  j | É d S(   s<    Add a new rule or replace the target for an existing rule. i    Rï   R
   s   (?:%s)s   anon%di   s
   (?P<%s>%s)Ns   ^(%s)$s   Could not add Route: %s (%s)c         Ä  sh   à |  É j  É  } xO à  D]G \ } } y | | | É | | <Wq t k
 r_ t d d É Ç q Xq W| S(   Niê  s   Path has wrong format.(   t	   groupdictt
   ValueErrort	   HTTPError(   Rä   t   url_argsRì   t   wildcard_filter(   Rí   t   re_match(    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   getargsh  s    c         Ä  s   à  |  É j  É  S(   N(   R¢   (   Rä   (   Rß   (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR®   q  s    s3   Route <%s %s> overwrites a previously defined route(   t   TrueR°   Rq   t   default_filterRí   R   Rá   RÄ   t   escapeRg   Rç   Rë   Ré   t
   setdefaultt   buildt   compileRû   t   errorRz   R   t
   groupindexRÉ   Rå   t   DEBUGRT   RU   t   RuntimeWarningRè   R}   t   _compile(   RI   Rõ   t   methodt   targetRì   t   anonst   keyst   patternRç   t	   is_staticRa   t   modeRÜ   t   maskt	   in_filtert
   out_filtert
   re_patternR®   t   flatpatt
   whole_rulet   msg(    (   Rí   Rß   s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   add>  sf     
   	!$c         CÄ  sÿ   |  j  | } g  } |  j | <|  j } x™ t d t | É | É D]ê } | | | | !} d Ñ  | DÉ } d j d Ñ  | DÉ É } t j | É j } g  | D] \ } } }	 }
 |	 |
 f ^ qô } | j	 | | f É q@ Wd  S(   Ni    c         sÄ  s!   |  ] \ } } } } | Vq d  S(   N(    (   t   .0t   _Rø   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pys	   <genexpr>ä  s    t   |c         sÄ  s   |  ] } d  | Vq d S(   s   (^%s$)N(    (   R√   Rø   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pys	   <genexpr>ã  s    (
   Rè   Rê   t   _MAX_GROUPS_PER_PATTERNt   rangeR}   t   joinRÄ   RÆ   Rû   R   (   RI   R¥   t	   all_rulest
   comborulest	   maxgroupsR    t   somet   combinedRƒ   Rµ   R®   Rã   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR≥   Ñ  s    	+c   
      OÄ  sÍ   |  j  j | É } | s* t d | É Ç n  yé x( t | É D] \ } } | | d | <q: Wd j g  | D]- \ } } | rå | | j | É É n | ^ qe É }	 | s• |	 S|	 d t | É SWn+ t k
 rÂ t d t É  j	 d É Ç n Xd S(   s2    Build an URL by filling the wildcards in a rule. s   No route with that name.s   anon%dRï   t   ?s   Missing URL argument: %ri    N(
   Rç   t   getR{   t	   enumerateR»   t   popR%   t   KeyErrorR   t   args(
   RI   t   _nameR∂   t   queryRç   t   iRm   t   nt   ft   url(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR≠   ê  s      C c         CÄ  s<  | d j  É  } | d p d } d } | d k rG d | d d g } n d | d g } xÿ | D]– } | |  j k r∏ | |  j | k r∏ |  j | | \ } } | | r± | | É n i  f S| |  j k r] xc |  j | D]Q \ } }	 | | É }
 |
 r’ |	 |
 j d \ } } | | r| | É n i  f Sq’ Wq] q] Wt g  É } t | É } x> t |  j É | D]) } | |  j | k r]| j | É q]q]Wx_ t |  j É | | D]F } x= |  j | D]. \ } }	 | | É }
 |
 r∂| j | É q∂q∂Wq¢W| rd	 j t | É É } t	 d
 d d | ÉÇ n  t	 d d t
 | É É Ç d S(   sD    Return a (target, url_agrs) tuple or raise HTTPError(400/404/405). t   REQUEST_METHODt	   PATH_INFOt   /t   HEADt   PROXYt   GETt   ANYi   t   ,iï  s   Method not allowed.t   Allowiî  s   Not found: N(   t   upperRg   Ré   Rê   t	   lastindexR\   R¬   R»   t   sortedR§   t   repr(   RI   t   environt   verbRä   Rµ   t   methodsR¥   R®   RÕ   Rã   Rû   t   allowedt   nocheckt   allow_header(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRû   õ  s<    "'N(   RK   RL   Rp   RÖ   R™   R∆   Rq   Rc   Rî   RÄ   RÆ   Rñ   R°   Rg   R¬   R≥   R≠   Rû   (    (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRÑ   ˇ   s   
		F		t   Routec           BÄ  sí   e  Z d  Z d d d d Ñ Z d Ñ  Z e d Ñ  É Z d Ñ  Z d Ñ  Z	 e
 d Ñ  É Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d d Ñ Z d Ñ  Z RS(   sÓ    This class wraps a route callback along with route specific metadata and
        configuration and applies Plugins on demand. It is also responsible for
        turing an URL path rule into a regular expression usable by the Router.
    c   	      KÄ  sp   | |  _  | |  _ | |  _ | |  _ | p- d  |  _ | p< g  |  _ | pK g  |  _ t É  j	 | d t
 É|  _ d  S(   Nt   make_namespaces(   t   appRõ   R¥   t   callbackRg   Rì   t   pluginst   skiplistt
   ConfigDictt	   load_dictR©   t   config(	   RI   RÔ   Rõ   R¥   R   Rì   RÒ   RÚ   Rı   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRc   Õ  s    				c         OÄ  s   t  d É |  j | | é  S(   Nsî   Some APIs changed to return Route() instances instead of callables. Make sure to use the Route.call method and not to call Route instances directly.(   RY   t   call(   RI   R4   RR   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR1   ‚  s    
c         CÄ  s
   |  j  É  S(   sç    The route callback with all plugins applied. This property is
            created on demand and then cached to speed up subsequent requests.(   t   _make_callback(   RI   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRˆ   Ë  s    c         CÄ  s   |  j  j d d É d S(   sk    Forget any cached values. The next time :attr:`call` is accessed,
            all plugins are re-applied. Rˆ   N(   Rs   R—   Rg   (   RI   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   resetÓ  s    c         CÄ  s   |  j  d S(   s:    Do all on-demand work immediately (useful for debugging).N(   Rˆ   (   RI   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   prepareÛ  s    c         CÄ  sY   t  d É t d |  j d |  j d |  j d |  j d |  j d |  j d |  j d	 |  j	 É S(
   Ns=   Switch to Plugin API v2 and access the Route object directly.Rõ   R¥   R   Rì   RÔ   Rı   t   applyt   skip(
   RY   R]   Rõ   R¥   R   Rì   RÔ   Rı   RÒ   RÚ   (   RI   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   _context˜  s    
!c         cÄ  s¬   t  É  } x≤ t |  j j |  j É D]ó } t |  j k r< Pn  t | d t É } | ru | |  j k s# | | k ru q# n  | |  j k s# t | É |  j k rü q# n  | rµ | j	 | É n  | Vq# Wd S(   s)    Yield all Plugins affecting this route. Rì   N(
   R\   t   reversedRÔ   RÒ   R©   RÚ   Rh   Rq   t   typeR¬   (   RI   t   uniqueRÇ   Rì   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   all_plugins˛  s    	  ! $  c         CÄ  s¬   |  j  } x≤ |  j É  D]§ } ya t | d É rp t | d d É } | d k rR |  n |  j } | j | | É } n | | É } Wn t k
 ró |  j É  SX| |  j  k	 r t | |  j  É q q W| S(   NR˙   t   apii   (	   R   R   R2   Rh   R¸   R˙   Rx   R˜   RN   (   RI   R   t   pluginR  t   context(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR˜   	  s    	c         CÄ  sx   |  j  } t | t r d n d | É } t r3 d n d } x8 t | | É rs t | | É rs t | | É d j } q< W| S(   sq    Return the callback. If the callback is a decorated function, try to
            recover the original function. t   __func__t   im_funct   __closure__t   func_closurei    (   R   Rh   t   py3kR2   t   cell_contents(   RI   Rf   t   closure_attr(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   get_undecorated_callback  s    	!c         CÄ  s   t  |  j É  É d S(   s”    Return a list of argument names the callback (most likely) accepts
            as keyword arguments. If the callback is a decorated function, try
            to recover the original function before inspection. i    (   R   R  (   RI   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   get_callback_args#  s    c         CÄ  s8   x1 |  j  |  j j f D] } | | k r | | Sq W| S(   sp    Lookup a config field and return its value, first checking the
            route.config, then route.app.config.(   Rı   RÔ   t   conifg(   RI   Ra   R
   RÜ   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt
   get_config)  s     c         CÄ  s#   |  j  É  } d |  j |  j | f S(   Ns
   <%s %r %r>(   R  R¥   Rõ   (   RI   t   cb(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   __repr__0  s    N(   RK   RL   Rp   Rg   Rc   R1   Rr   Rˆ   R¯   R˘   t   propertyR¸   R   R˜   R  R  R  R  (    (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRÌ   «  s   						
	t   Bottlec           BÄ  s[  e  Z d  Z e e d Ñ Z e d d É Z d& Z d Z e	 d Ñ  É Z
 d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d' d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d' d d' d' d' d' d Ñ Z d' d d Ñ Z d' d d Ñ Z d' d d Ñ Z d' d d Ñ Z d d  Ñ Z d! Ñ  Z  d" Ñ  Z! d' d# Ñ Z" d$ Ñ  Z# d% Ñ  Z$ RS((   s^   Each Bottle object represents a single, distinct web application and
        consists of routes, callbacks, plugins, resources and configuration.
        Instances are callable WSGI applications.

        :param catchall: If true (default), handle all exceptions. Turn off to
                         let debugging middleware handle exceptions.
    c         CÄ  s‘   t  É  |  _ t j |  j d É |  j _ |  j j d d t É |  j j d d t É | |  j d <| |  j d <t É  |  _	 g  |  _
 t É  |  _ i  |  _ g  |  _ |  j d r¿ |  j t É  É n  |  j t É  É d  S(   NRı   t   autojsont   validatet   catchall(   RÛ   Rı   RM   t   partialt   trigger_hookt
   _on_changet   meta_sett   boolt   ResourceManagert	   resourcest   routesRÑ   t   routert   error_handlerRÒ   t   installt
   JSONPlugint   TemplatePlugin(   RI   R  R  (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRc   G  s    			Rı   R  t   before_requestt   after_requestt	   app_resetc         CÄ  s   t  d Ñ  |  j DÉ É S(   Nc         sÄ  s   |  ] } | g  f Vq d  S(   N(    (   R√   Rì   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pys	   <genexpr>f  s    (   R]   t   _Bottle__hook_names(   RI   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   _hooksd  s    c         CÄ  sA   | |  j  k r) |  j | j d | É n |  j | j | É d S(   s´   Attach a callback to a hook. Three hooks are currently implemented:

            before_request
                Executed once before each request. The request context is
                available, but no routing has happened yet.
            after_request
                Executed once after each request regardless of its outcome.
            app_reset
                Called whenever :meth:`Bottle.reset` is called.
        i    N(   t   _Bottle__hook_reversedR'  t   insertR   (   RI   Rì   Rf   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   add_hookh  s    c         CÄ  s>   | |  j  k r: | |  j  | k r: |  j  | j | É t Sd S(   s     Remove a callback from a hook. N(   R'  t   removeR©   (   RI   Rì   Rf   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   remove_hookx  s    "c         OÄ  s(   g  |  j  | D] } | | | é  ^ q S(   s.    Trigger a hook and return a list of results. (   R'  (   RI   t   _Bottle__nameR”   t   kwargst   hook(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR  ~  s    c         Ä  s   á  á f d Ü  } | S(   se    Return a decorator that attaches a callback to a hook. See
            :meth:`add_hook` for details.c         Ä  s   à j  à  |  É |  S(   N(   R*  (   Rf   (   Rì   RI   (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt	   decoratorÖ  s    (    (   RI   Rì   R0  (    (   Rì   RI   s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR/  Ç  s    c         Ä  s  t  à  t É r t d t É n  g  | j d É D] } | r/ | ^ q/ } | s\ t d É Ç n  t | É â á  á f d Ü  } | j d t É | j d d É | j d i | d	 6à  d
 6É | | d <|  j d d j	 | É | ç | j
 d É s|  j d d j	 | É | ç n  d S(   sø   Mount an application (:class:`Bottle` or plain WSGI) to a specific
            URL prefix. Example::

                root_app.mount('/admin/', admin_app)

            :param prefix: path prefix or `mount-point`. If it ends in a slash,
                that slash is mandatory.
            :param app: an instance of :class:`Bottle` or a WSGI application.

            All other parameters are passed to the underlying :meth:`route` call.
        s*   Parameter order of Bottle.mount() changed.R‹   s   Empty path prefix.c          Ä  sî   z~ t  j à É t g  É â  d  á  f d Ü }  à t  j |  É } | rg à  j rg t j à  j | É } n  | ps à  j à  _ à  SWd  t  j à É Xd  S(   Nc         Ä  s[   | r! z t  | å  Wd  d  } Xn  |  à  _ x$ | D] \ } } à  j | | É q1 Wà  j j S(   N(   R5   Rg   t   statust
   add_headert   bodyR   (   R1  t
   headerlistR   Rì   Rm   (   t   rs(    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   start_response°  s    
	 (   t   requestt
   path_shiftt   HTTPResponseRg   RÁ   R3  t	   itertoolst   chain(   R6  R3  (   RÔ   t
   path_depth(   R5  s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   mountpoint_wrapperù  s    	 R˚   R¥   Rﬁ   t
   mountpointRù   Rµ   R   s   /%s/<:re:.*>N(   R>   t
   basestringRY   R©   t   splitR£   R}   R¨   t   routeR»   t   endswith(   RI   Rù   RÔ   t   optionsRÇ   t   segmentsR=  (    (   RÔ   R<  s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   mountä  s    ( 
c         CÄ  s=   t  | t É r | j } n  x | D] } |  j | É q" Wd S(   sÙ    Merge the routes of another :class:`Bottle` application or a list of
            :class:`Route` objects into this application. The routes keep their
            'owner', meaning that the :data:`Route.app` attribute is not
            changed. N(   R>   R  R  t	   add_route(   RI   R  RA  (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   merge∫  s    c         CÄ  si   t  | d É r | j |  É n  t | É rK t  | d É rK t d É Ç n  |  j j | É |  j É  | S(   s‚    Add a plugin to the list of plugins and prepare it for being
            applied to all routes of this application. A plugin may be a simple
            decorator or an object that implements the :class:`Plugin` API.
        t   setupR˙   s.   Plugins must be callable or implement .apply()(   R2   RH  t   callablet	   TypeErrorRÒ   R   R¯   (   RI   R  (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR   ƒ  s     
c         CÄ  sœ   g  | } } x® t  t |  j É É d d d Ö D]Ñ \ } } | t k s~ | | k s~ | t | É k s~ t | d t É | k r0 | j | É |  j | =t | d É r¥ | j É  q¥ q0 q0 W| rÀ |  j	 É  n  | S(   s)   Uninstall plugins. Pass an instance to remove a specific plugin, a type
            object to remove all plugins that match that type, a string to remove
            all plugins with a matching ``name`` attribute or ``True`` to remove all
            plugins. Return the list of removed plugins. NiˇˇˇˇRì   RJ   (
   R[   R–   RÒ   R©   R˛   Rh   R   R2   RJ   R¯   (   RI   R  t   removedR+  R÷   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt	   uninstall–  s    /*
  c         CÄ  sì   | d k r |  j } n+ t | t É r3 | g } n |  j | g } x | D] } | j É  qJ Wt rÇ x | D] } | j É  qk Wn  |  j d É d S(   s™    Reset all routes (force plugins to be re-applied) and clear all
            caches. If an ID or route object is given, only that specific route
            is affected. R%  N(   Rg   R  R>   RÌ   R¯   R±   R˘   R  (   RI   RA  R  (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR¯   ﬂ  s        c         CÄ  s=   x- |  j  D]" } t | d É r
 | j É  q
 q
 Wt |  _ d S(   s2    Close the application and all installed plugins. RJ   N(   RÒ   R2   RJ   R©   t   stopped(   RI   R  (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRJ   Î  s     c         KÄ  s   t  |  | ç d S(   s-    Calls :func:`run` with the same parameters. N(   t   run(   RI   R.  (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRN  Ò  s    c         CÄ  s   |  j  j | É S(   s›    Search for a matching route and return a (:class:`Route` , urlargs)
            tuple. The second value is a dictionary with parameters extracted
            from the URL. Raise :exc:`HTTPError` (404/405) on a non-match.(   R  Rû   (   RI   RÁ   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRû   ı  s    c         KÄ  sV   t  j j d d É j d É d } |  j j | | ç j d É } t t d | É | É S(   s,    Return a string that matches a named route t   SCRIPT_NAMERï   R‹   (   R7  RÁ   Rœ   t   stripR  R≠   t   lstripR#   (   RI   t	   routenamet   kargst
   scriptnamet   location(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   get_url˚  s    "c         CÄ  sL   |  j  j | É |  j j | j | j | d | j Ét rH | j É  n  d S(   sS    Add a route object, but do not change the :data:`Route.app`
            attribute.Rì   N(	   R  R   R  R¬   Rõ   R¥   Rì   R±   R˘   (   RI   RA  (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRF    s    % Rﬂ   c   	      Ä  si   t  à É r d à â } n  t | É â t | É â á  á á á á á á f d Ü  } | re | | É S| S(   s   A decorator to bind a function to a request URL. Example::

                @app.route('/hello/:name')
                def hello(name):
                    return 'Hello %s' % name

            The ``:name`` part is a wildcard. See :class:`Router` for syntax
            details.

            :param path: Request path or a list of paths to listen to. If no
              path is specified, it is automatically generated from the
              signature of the function.
            :param method: HTTP method (`GET`, `POST`, `PUT`, ...) or a list of
              methods to listen to. (default: `GET`)
            :param callback: An optional shortcut to avoid the decorator
              syntax. ``route(..., callback=func)`` equals ``route(...)(func)``
            :param name: The name for this route. (default: None)
            :param apply: A decorator or plugin or a list of plugins. These are
              applied to the route callback in addition to installed plugins.
            :param skip: A list of plugins, plugin classes or names. Matching
              plugins are not installed to this route. ``True`` skips all.

            Any additional keyword arguments are stored as route-specific
            configuration and passed to plugins (see :meth:`Plugin.apply`).
        c         Ä  sü   t  |  t É r t |  É }  n  xz t à É p6 t |  É D]` } xW t à É D]I } | j É  } t à | | |  d à d à d à à  ç} à j | É qJ Wq7 W|  S(   NRì   RÒ   RÚ   (   R>   R?  t   loadR^   t   yieldroutesR„   RÌ   RF  (   R   Rõ   RË   RA  (   Rı   R¥   Rì   Rä   RÒ   RI   RÚ   (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR0  &  s     N(   RI  Rg   R^   (	   RI   Rä   R¥   R   Rì   R˙   R˚   Rı   R0  (    (   Rı   R¥   Rì   Rä   RÒ   RI   RÚ   s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRA    s     !
c         KÄ  s   |  j  | | | ç S(   s    Equals :meth:`route`. (   RA  (   RI   Rä   R¥   RC  (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRœ   2  s    t   POSTc         KÄ  s   |  j  | | | ç S(   s8    Equals :meth:`route` with a ``POST`` method parameter. (   RA  (   RI   Rä   R¥   RC  (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   post6  s    t   PUTc         KÄ  s   |  j  | | | ç S(   s7    Equals :meth:`route` with a ``PUT`` method parameter. (   RA  (   RI   Rä   R¥   RC  (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   put:  s    t   DELETEc         KÄ  s   |  j  | | | ç S(   s:    Equals :meth:`route` with a ``DELETE`` method parameter. (   RA  (   RI   Rä   R¥   RC  (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   delete>  s    iÙ  c         Ä  s   á  á f d Ü  } | S(   s<    Decorator: Register an output handler for a HTTP error codec         Ä  s   |  à j  t à  É <|  S(   N(   R  Rà   (   t   handler(   t   codeRI   (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRP   D  s    (    (   RI   R`  RP   (    (   R`  RI   s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRØ   B  s    c         CÄ  s   t  t t d | ÉÉ S(   Nt   e(   RC   t   templatet   ERROR_PAGE_TEMPLATE(   RI   t   res(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   default_error_handlerI  s    c         CÄ  sã  | d } | d <t  rY y  | j d É j d É | d <WqY t k
 rU t d d É SXn  yä |  | d <t j | É t j É  zT |  j d É |  j	 j
 | É \ } } | | d	 <| | d
 <| | d <| j | ç  SWd  |  j d É XWn° t k
 r˙ t É  St k
 r| j É  |  j | É St t t f k
 r:Ç  nM t k
 rÜ|  j sVÇ  n  t É  } | d j | É t d d t É  | É SXd  S(   NR€   s   bottle.raw_pathR)   R=   iê  s#   Invalid path string. Expected UTF-8s
   bottle.appR#  s   route.handles   bottle.routes   route.url_argsR$  s   wsgi.errorsiÙ  s   Internal Server Error(   R  R@   RE   t   UnicodeErrorR§   R7  t   bindt   responseR  R  Rû   Rˆ   R9  R   Rx   R¯   t   _handlet   KeyboardInterruptt
   SystemExitt   MemoryErrort	   ExceptionR  R   R   (   RI   RÁ   Rä   RA  R”   t
   stacktrace(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRi  L  s>     





	 	c         CÄ  s$  | s# d t  k r d t  d <n  g  St | t t f É rn t | d t t f É rn | d d d !j | É } n  t | t É rí | j t  j É } n  t | t É r« d t  k r¿ t	 | É t  d <n  | g St | t
 É r| j t  É |  j j | j |  j É | É } |  j | É St | t É r=| j t  É |  j | j É St | d É ròd t j k rlt j d | É St | d É sãt | d É ròt | É Sn  y5 t | É } t | É } x | sÀt | É } q∂WWnä t k
 rÍ|  j d É St k
 rt É  } nW t t t f k
 rÇ  n; t k
 rY|  j s;Ç  n  t
 d d	 t É  t  É  É } n Xt | t É rv|  j | É St | t É rùt! j" | g | É } n_ t | t É r÷d
 Ñ  } t# | t! j" | g | É É } n& d t$ | É } |  j t
 d | É É St | d É r t% | | j& É } n  | S(   s˛    Try to convert the parameter into something WSGI compatible and set
        correct HTTP headers when possible.
        Support: False, str, unicode, dict, HTTPResponse, HTTPError, file-like,
        iterable of strings and iterable of unicodes
        s   Content-Lengthi    t   reads   wsgi.file_wrapperRJ   t   __iter__Rï   iÙ  s   Unhandled exceptionc         SÄ  s   |  j  t j É S(   N(   R@   Rh  t   charset(   R    (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR!   Æ  s    s   Unsupported response type: %s('   Rh  R>   RZ   R[   RA   R?   R»   R@   Rq  R}   R§   R˙   R  Rœ   t   status_codeRe  t   _castR9  R3  R2   R7  RÁ   t   WSGIFileWrappert   iterR:   t   StopIterationR   Rj  Rk  Rl  Rm  R  R   R:  R;  R6   R˛   t
   _closeiterRJ   (   RI   t   outt   peekt   ioutt   firstt   new_itert   encoderR¡   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRs  o  sh    !		 	!c         CÄ  sE  yw |  j  |  j | É É } t j d k s: | d d k r_ t | d É rV | j É  n  g  } n  | t j t j É | SWn« t t	 t
 f k
 rñ Ç  n´ t k
 r@|  j s≤ Ç  n  d t | j d	 d
 É É } t r| d t t t É  É É t t É  É f 7} n  | d j | É d g } | d | t j É  É t | É g SXd S(   s    The bottle WSGI-interface. id   ie   iÃ   i0  R⁄   R›   RJ   s4   <h1>Critical error while processing request: %s</h1>R€   R‹   sD   <h2>Error:</h2>
<pre>
%s
</pre>
<h2>Traceback:</h2>
<pre>
%s
</pre>
s   wsgi.errorss   Content-Types   text/html; charset=UTF-8s   500 INTERNAL SERVER ERRORN(   id   ie   iÃ   i0  (   s   Content-Types   text/html; charset=UTF-8(   Rs  Ri  Rh  t   _status_codeR2   RJ   t   _status_lineR4  Rj  Rk  Rl  Rm  R  t   html_escapeRœ   R±   RÊ   R   R   R   R   R   RC   (   RI   RÁ   R6  Rx  RF   t   headers(    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyt   wsgi∑  s.     		 )	c         CÄ  s   |  j  | | É S(   s9    Each instance of :class:'Bottle' is a WSGI application. (   RÇ  (   RI   RÁ   R6  (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR1   —  s    (   s   before_requests   after_requests	   app_resets   configN(%   RK   RL   Rp   R©   Rc   R_   R  R&  R(  Rr   R'  R*  R,  R  R/  RE  RG  R   RL  Rg   R¯   RJ   RN  Rû   RV  RF  RA  Rœ   RZ  R\  R^  RØ   Re  Ri  Rs  RÇ  R1   (    (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyR  >  s@   					0	
							)		#H	t   BaseRequestc           BÄ  s;  e  Z d  Z d Z d Z d@ d Ñ Z e d d d e Éd Ñ  É Z	 e d d d e Éd Ñ  É Z
 e d d	 d e Éd
 Ñ  É Z e d Ñ  É Z e d Ñ  É Z e d d d e Éd Ñ  É Z d@ d Ñ Z e d d d e Éd Ñ  É Z d@ d@ d Ñ Z e d d d e Éd Ñ  É Z e d d d e Éd Ñ  É Z e d d d e Éd Ñ  É Z e d d d e Éd Ñ  É Z e d d d e Éd Ñ  É Z d Ñ  Z d Ñ  Z e d d d e Éd  Ñ  É Z d! Ñ  Z e d" Ñ  É Z e d# Ñ  É Z e Z e d d$ d e Éd% Ñ  É Z e d& Ñ  É Z  e d d' d e Éd( Ñ  É Z! e d) Ñ  É Z" e d* Ñ  É Z# e d+ Ñ  É Z$ d, d- Ñ Z% e d. Ñ  É Z& e d/ Ñ  É Z' e d0 Ñ  É Z( e d1 Ñ  É Z) e d2 Ñ  É Z* e d3 Ñ  É Z+ e d4 Ñ  É Z, d5 Ñ  Z- d@ d6 Ñ Z. d7 Ñ  Z/ d8 Ñ  Z0 d9 Ñ  Z1 d: Ñ  Z2 d; Ñ  Z3 d< Ñ  Z4 d= Ñ  Z5 d> Ñ  Z6 d? Ñ  Z7 RS(A   sd   A wrapper for WSGI environment dictionaries that adds a lot of
        convenient access methods and properties. Most of them are read-only.

        Adding new attributes to a request actually adds them to the environ
        dictionary (as 'bottle.request.ext.<name>'). This is the recommended
        way to store and access request-specific data.
    RÁ   i ê c         CÄ  s,   | d k r i  n | |  _ |  |  j d <d S(   s!    Wrap a WSGI environ dictionary. s   bottle.requestN(   Rg   RÁ   (   RI   RÁ   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRc   Ï  s    s
   bottle.appRb   c         CÄ  s   t  d É Ç d S(   s+    Bottle application handling this request. s0   This request is not connected to an application.N(   t   RuntimeError(   RI   (    (    s3   C:\Users\Simon\Documents\BitToyrrent\libs\bottle.pyRÔ   Û  s    s   bottle.routec         CÄ  s   t  d É Ç d S(   s=    The bottle :class:`